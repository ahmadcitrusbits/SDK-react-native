
import { NativeModules, NativeEventEmitter } from 'react-native';

const { RNQualtricsDigital } = NativeModules;

const Q_LOGTAG = "Qualtrics: ";
const REACT_NATIVE_PROPERTY = "Qualtrics_IS_REACT_NATIVE";

/* Set up validating function parameter types */
// Parameter IDs
// Add constant for new function parameters
const BRAND_ID = 'brandid';
const PROJECT_ID = 'projectid';
const INTERCEPT_ID = 'interceptid';
const EXT_REF_ID = 'extrefid';
const CALLBACK = 'callback';
const VIEW_NAME = 'viewName';
const PROPERTY_KEY = 'propertyKey';
const PROPERTY_STRING = 'propertyString';
const PROPERTY_NUMBER = 'propertyNumber';
const PROPERTY_ASSET = 'propertyAsset';

const INITIALIZATION_EVENT = "initializeEvent";
const EVALUATE_EVENT = "evaluateEvent";
const INITIALIZE_PROJECT_EVENT = "initializeProjectEvent";
const EVALUATE_PROJECT_EVENT = "evaluateProjectEvent";
const EVALUATE_INTERCEPT_EVENT = "evaluateInterceptEvent";

// Parameter Types
// add constant for new function parameter types
const STRING_TYPE = 'string';
const FUNCTION_TYPE = 'function';
const NUMBER_TYPE = 'number';

// Parameter IDs to Parameter Types Dictionary
// add parameter ID as key and parameter type as value
const EXPECTED_PARAMETER_TYPES = {
  [BRAND_ID]: STRING_TYPE,
  [PROJECT_ID]: STRING_TYPE,
  [INTERCEPT_ID]: STRING_TYPE,
  [EXT_REF_ID]: STRING_TYPE,
  [CALLBACK]: FUNCTION_TYPE,
  [VIEW_NAME]: STRING_TYPE,
  [PROPERTY_KEY]: STRING_TYPE,
  [PROPERTY_STRING]: STRING_TYPE,
  [PROPERTY_NUMBER]: NUMBER_TYPE,
  [PROPERTY_ASSET]: STRING_TYPE
};

const eventEmitter = new NativeEventEmitter(RNQualtricsDigital);

/* End validate parameter types setup */

/**
 * @class
 * @classdesc a class used to hold the results of the initialization methods
 * @property {boolean} passed - whether or not initialization succeeded 
 * @property {string} surveyUrl  - initialization message used to determine initialization status
 */
class InitializationResult {
  constructor(passed, message) {
    this.passed = passed;
    this.message = message;
  }
}
/**
 * @class
 * @classdesc a class used to hold the results of the evaluation methods
 * @property {boolean} passed - whether or not target evaluation succeeded 
 * @property {string} surveyUrl - link to the survey in Creative where logic evaluation passed. url used to display survey in display()
 * @property {string} creativeType - the type of the creative associated with the passing action set.
 */
class TargetingResult {
  constructor(passed, surveyUrl, creativeType) {
    this.passed = passed;
    this.surveyUrl = surveyUrl;
    this.creativeType = creativeType;
  }

  /**
   * @method recordClick() - void method
   * @description records a click to the server associated with intercept
   */
  recordClick() {
    try {
      RNQualtricsDigital.recordClick();
    } catch(error) {
      console.log(Q_LOGTAG + 'recordClick() failed -- ' + error);
    }
  }

  /**
   * @method recordImpression() - void method
   * @description records an impression to the server associated with intercept
   */
  recordImpression() {
    try {
      RNQualtricsDigital.recordImpression();
    } catch(error) {
      console.log(Q_LOGTAG + 'recordImpression() failed -- ' + error);
    }
  }
}

/* validateParameterTypes() - void helper method
 * throws error if function parameters do not match expected parameter types
 */
function validateParameterTypes(parameters) {
  for(var p_key in parameters) { 
    if (parameters.hasOwnProperty(p_key) && EXPECTED_PARAMETER_TYPES.hasOwnProperty(p_key)) {
      let paramType = typeof parameters[p_key];
      if (paramType !== EXPECTED_PARAMETER_TYPES[p_key]) {
        throw new TypeError(p_key + ' parameter did not match expected type of ' + EXPECTED_PARAMETER_TYPES[p_key]);
      }
    }
  }
}

function isWaitingForEventToFinish(eventType) {
  return eventEmitter && eventEmitter.listenerCount(eventType) && eventEmitter.listenerCount(eventType) > 0;
}

/** initializeProject() - void method
 * @description initializes Qualtrics singleton with specified params
 * @param {string} - intercept brand id
 * @param {string} - intercept project/zone id
 * @param {callback} [callback] - optional method called, if defined, to handle initializationResults
 * @returns {initializationResults} to the callback
 */
function initializeProject(brandid, projectid, callback) {
  initializeProject(brandid, projectid, null, callback);
}

/** initializeProjectWithExtRefId() - void method
 * @description initializes Qualtrics singleton with specified params
 * @param {string} - intercept brand id
 * @param {string} - intercept project/zone id
 * @param {string} - external reference id
 * @param {callback} [callback] - optional method called, if defined, to handle initializationResults
 * @returns {initializationResults} to the callback
 */
function initializeProjectWithExtRefId(brandid, projectid, extrefid, callback) {
  let functionParameters = {
    [BRAND_ID]: brandid,
    [PROJECT_ID]: projectid,
    [EXT_REF_ID]: extrefid,
    [CALLBACK]: callback
  };

  try {
    RNQualtricsDigital.setString(REACT_NATIVE_PROPERTY, 'true');
    validateParameterTypes(functionParameters);

    if (isWaitingForEventToFinish(INITIALIZE_PROJECT_EVENT)) {
      var errorResult = {};
      errorResult["ERROR"] = new InitializationResult(false, 'Invalid InitializationResult Received');
      callback(errorResult);
      return;
    }
    eventEmitter.addListener(INITIALIZE_PROJECT_EVENT, (result) => {
      if (result !== null) {
        var initializationResults = {};
        for (var interceptId in result) {
          if (Object.prototype.hasOwnProperty.call(result, interceptId)) {
              if (result[interceptId].message && result[interceptId].passed) {
                initializationResults[interceptId] = new InitializationResult(result[interceptId].passed, result[interceptId].message);
              }
          }
        }
        callback(initializationResults);
      } else {
        var errorResult = {};
        errorResult["ERROR"] = new InitializationResult(false, 'Invalid InitializationResult Received');
        callback(errorResult);
      }
      eventEmitter.removeAllListeners(INITIALIZE_PROJECT_EVENT);
    });
    RNQualtricsDigital.initializeProject(brandid, projectid, extrefid);
  } catch(error) {
    console.log(Q_LOGTAG + 'initializeProject() failed -- ' + error);
  }
}

/** initialize() 
 * @description initializes Qualtrics singleton with specified params
 * @deprecate marked for future deprecation with version 2.0.0
 * @param {string} - intercept brand id
 * @param {string} - intercept project/zone id
 * @param {string} - intercept id
 * @param {callback} [callback] - optional method called, if defined, to handle the InitializationResult
 * @returns {InitializationResult} in callback
 */
function initialize(brandid, projectid, interceptid, callback) {
  // Build dictionary of required parameters for type validation
  let functionParameters = {
    [BRAND_ID]: brandid,
    [PROJECT_ID]: projectid,
    [INTERCEPT_ID]: interceptid,
  };

  try {
    RNQualtricsDigital.setString(REACT_NATIVE_PROPERTY, 'true');
    if (typeof callback === 'undefined') {
      validateParameterTypes(functionParameters);
      RNQualtricsDigital.initialize(brandid, projectid, interceptid);
    } else {
      // Add callback to required parameters
      functionParameters[CALLBACK] = callback;
      validateParameterTypes(functionParameters);
      
      if (isWaitingForEventToFinish(INITIALIZATION_EVENT)) {
        callback(new InitializationResult(false, 'Initialization already in progress'));
        return;
      }
      eventEmitter.addListener(INITIALIZATION_EVENT, (result) => {
        if (result !== null) {
          callback(new InitializationResult(result.passed, result.message));
        } else {
          callback(new InitializationResult(false, 'Invalid InitializationResult Received'));
        }
        eventEmitter.removeAllListeners(INITIALIZATION_EVENT);
      });
      RNQualtricsDigital.initializeWithCompletion(brandid, projectid, interceptid);
    }
  } catch(error) {
    console.log(Q_LOGTAG + 'initialize() failed -- ' + error);
  }
}

/** evaluateProject() - void method
 * @description evaluates all the initialized intercepts and calls callback
 * @param {callback} - method called to handle TargetingResults, must be defined
 * @returns {TargetingResults} in callback
 */
function evaluateProject(callback) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [CALLBACK]: callback,
  };

  try {
    validateParameterTypes(functionParameters);

    if (isWaitingForEventToFinish(EVALUATE_PROJECT_EVENT)) {
      var errorResult = {};
      errorResult["ERROR"] = new TargetingResult(false, 'Evaluation already in progress', "");
      callback(errorResult);
      return;
    }
    eventEmitter.addListener(EVALUATE_PROJECT_EVENT, (result) => {
      if (result !== null) {

        var targetingResults = {};

        for (var interceptId in result) {
          if (Object.prototype.hasOwnProperty.call(result, interceptId)) {
            targetingResults[interceptId] = new TargetingResult(result[interceptId].passed, result[interceptId].surveyUrl, result[interceptId].creativeType);
          }
        }

        callback(targetingResults);
      } else {
        var errorResult = {};
        errorResult["ERROR"] = new TargetingResult(false, 'Invalid TargetingResult Received', '');
        callback(errorResult);
      }
      eventEmitter.removeAllListeners(EVALUATE_PROJECT_EVENT);
    });
    RNQualtricsDigital.evaluateProject();
  } catch(error) {
    console.log(Q_LOGTAG + 'evaluateProject() failed -- ' + error);
  }
}

/** evaluateIntercept() - void method
 * @description evaluates the passed intercept and calls callback
 * @param {callback} - method called to handle TargetingResult, must be defined
 * @returns {TargetingResults} in callback
 */
function evaluateIntercept(interceptId, callback) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [CALLBACK]: callback,
  };

  try {
    validateParameterTypes(functionParameters);

    if (isWaitingForEventToFinish(EVALUATE_INTERCEPT_EVENT)) {
      callback(new TargetingResult(false, 'Evaluation already in progress', ''));
      return;
    }
    eventEmitter.addListener(EVALUATE_INTERCEPT_EVENT, (result) => {
      if (result !== null) {
        callback(new TargetingResult(result.passed, result.surveyUrl, result.creativeType));
      } else {
        callback(new TargetingResult(false, 'Invalid TargetingResult Received', ''));
      }
      eventEmitter.removeAllListeners(EVALUATE_INTERCEPT_EVENT);
    });

    RNQualtricsDigital.evaluateIntercept(interceptId);
  } catch(error) {
    console.log(Q_LOGTAG + 'evaluateIntercept() failed -- ' + error);
  }
}

/** evaluateTargetingLogic() - void method
 * @deprecate marked for future deprecation with version 2.0.0
 * @description evaluates current intercept and calls callback
 * @param {callback} - method called, to handle TargetingResult, must be defined
 * @return {TargetingResult} in callback
 */
function evaluateTargetingLogic(callback) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [CALLBACK]: callback,
  };

  try {
    validateParameterTypes(functionParameters);

    if (isWaitingForEventToFinish(EVALUATE_EVENT)) {
      callback(new TargetingResult(false, 'Evaluation already in progress'));
      return;
    }
    eventEmitter.addListener(EVALUATE_EVENT, (result) => {
      if (result !== null) {
        callback(new TargetingResult(result.passed, result.surveyUrl));
      } else {
        callback(new TargetingResult(false, 'Invalid TargetingResult Received'));
      }
      eventEmitter.removeAllListeners(EVALUATE_EVENT);
    });
    RNQualtricsDigital.evaluateTargetingLogic();
  } catch(error) {
    console.log(Q_LOGTAG + 'evaluateTargetingLogic() failed -- ' + error);
  }
}

/** display() - bool return method
 * @description displays creative in the view controller
 * @returns {Promise} Promise object representing a bool
 */
function display() {
  const displayPromise = new Promise((resolve, reject) => {
    try {
      RNQualtricsDigital.display((result) => {
        if (result) {
          resolve(true);
        }
        reject(false);
      });
    } catch(error) {
      console.log(Q_LOGTAG + 'display() failed -- ' + error);
      reject(false);
    }
  });
  return displayPromise;
}

/** displayIntercept() - bool return method
 * @description displays creative in the view controller
 * @returns {Promise} Promise object representing a bool
 */
function displayIntercept(interceptId) {
  const displayPromise = new Promise((resolve, reject) => {
    try {
      RNQualtricsDigital.displayIntercept(interceptId, (result) => {
        if (result) {
          resolve(true);
        }
        reject(false);
      });
    } catch(error) {
      console.log(Q_LOGTAG + 'displayIntercept() failed -- ' + error);
      reject(false);
    }
  });
  return displayPromise;
}

/**
 * 
 * @returns Returns an array of all the initialized intercepts
 */
function getInitializedIntercepts() {
  const interceptPrmoise = new Promise((resolve, reject) => {
    try {
      RNQualtricsDigital.getInitializedIntercepts((intercepts) => {
        console.log(intercepts);
        resolve(intercepts);
      });
    } catch(error) {
      resolve("");
    }
  });

  return interceptPrmoise;
}

/**
 * 
 * @returns Returns an array of all the passing intercepts
 */
function getPassingIntercepts() {
  const interceptPrmoise = new Promise((resolve, reject) => {
    try {
      RNQualtricsDigital.getPassingIntercepts((intercepts) => {
        console.log(intercepts);
        resolve(intercepts);
      });
    } catch(error) {
      resolve("");
    }
  });

  return interceptPrmoise;
}

/** registerViewVisit() - void method
 * @description record visits to a particular view
 * @param {string} - name of view to record
 */
function registerViewVisit(viewName) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [VIEW_NAME]: viewName,
  };

  try {
    validateParameterTypes(functionParameters);
    RNQualtricsDigital.registerViewVisit(viewName);
  } catch(error) {
    console.log(Q_LOGTAG + 'registerViewVisit() failed -- ' + error);
  }
}

/** resetTimer() - void method
 * @description resets timer used for Time Spent In App
 */
function resetTimer() {
  try {
    RNQualtricsDigital.resetTimer();
  } catch(error) {
    console.log(Q_LOGTAG + 'resetTimer() failed -- ' + error);
  }
}

/** resetViewCounter() - void method
 * @description resets view count used for View Count
 */
function resetViewCounter() {
  try {
    RNQualtricsDigital.resetViewCounter();
  } catch(error) {
    console.log(Q_LOGTAG + 'resetViewCounter() failed -- ' + error);
  }
}

/** setString() - void method
 * @description sets string value for specified key in properties
 * @param {string} - Key for value
 * @param {string} - String value to assign with key
 */
function setString(propertyKey, propertyString) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [PROPERTY_KEY]: propertyKey,
    [PROPERTY_STRING]: propertyString,
  };

  try {
    validateParameterTypes(functionParameters);
    RNQualtricsDigital.setString(propertyKey, propertyString);
  } catch(error) {
    console.log(Q_LOGTAG + 'setString() failed -- ' + error);
  }
}

/** setNumber() - void method
 * @description sets double value for specified key in properties
 * @param {string} - Key for value
 * @param {number} - Numeric value to assign with key
 */
function setNumber(propertyKey, propertyNumber) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [PROPERTY_KEY]: propertyKey,
    [PROPERTY_NUMBER]: propertyNumber,
  };

  try {
    validateParameterTypes(functionParameters);
    RNQualtricsDigital.setNumber(propertyKey, propertyNumber);
  } catch(error) {
    console.log(Q_LOGTAG + 'setNumber() failed -- ' + error);
  }
}

/** setDateTime() - void method
 * @description sets current datetime value for specified key in properties
 * @param {string} - Key for value
 */
function setDateTime(propertyKey) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [PROPERTY_KEY]: propertyKey
  };

  try {
    validateParameterTypes(functionParameters);
    RNQualtricsDigital.setDateTime(propertyKey);
  } catch(error) {
    console.log(Q_LOGTAG + 'setDateTime() failed -- ' + error);
  }
}

/** setNotificationIconAsset() - void method
 * @description Sets string file name for notificationIconAsset in properties
 * @param {string} propertyAsset - File name of Image stored in Drawable folder of Android Project
 */
function setNotificationIconAsset(propertyAsset) {
  // Build dictionary of required parameters for type validation
  const functionParameters = {
    [PROPERTY_ASSET]: propertyAsset
  };

  try {
    validateParameterTypes(functionParameters);
    RNQualtricsDigital.setNotificationIconAsset(propertyAsset);
  } catch(error) {
    console.log(Q_LOGTAG + 'setNotificationIconAsset() failed -- ' + error);
  }
}

/** displayTarget() - void method
 * @description displays evaluated TargetingResult in webview
 */
function displayTarget() {
  try {
    RNQualtricsDigital.displayTarget((displayTargetResult) => {
      // Display target failed; log error
      if (!displayTargetResult) {
        console.log(Q_LOGTAG + 'displayTarget() failed -- no TargetingResult with valid target URL');
      }
    });
  } catch(error) {
    console.log(Q_LOGTAG + 'displayTarget() failed -- ' + error);
  }
}

module.exports = {
  initialize: initialize,
  initializeProject: initializeProject,
  initializeProjectWithExtRefId: initializeProjectWithExtRefId,
  evaluateTargetingLogic: evaluateTargetingLogic,
  evaluateIntercept: evaluateIntercept,
  evaluateProject: evaluateProject,
  display: display,
  displayIntercept: displayIntercept,
  registerViewVisit: registerViewVisit,
  resetTimer: resetTimer,
  resetViewCounter: resetViewCounter,
  setString: setString,
  setNumber: setNumber,
  setDateTime: setDateTime,
  setNotificationIconAsset: setNotificationIconAsset,
  displayTarget: displayTarget,
  getInitializedIntercepts: getInitializedIntercepts,
  getPassingIntercepts:getPassingIntercepts,
  InitializationResult,
  TargetingResult,
  RNQualtricsDigital
};
