/**
 * react-native-qualtrics // npm module
 * unit tests for evaluateTargetingLogic()
 */

import Qualtrics, {
    RNQualtricsDigital,
    evaluateTargetingLogic
} from '../../index.js';

import { NativeModules, NativeEventEmitter } from 'react-native';

var mockTargetingResult = {};
var successMessage = 'evaluateTargetingLogic successful';
var typeError = 'TypeError';

const spyConsoleLog = jest.spyOn(global.console, 'log');

jest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');
const nativeEventEmitter = new NativeEventEmitter();

jest.mock('react-native/Libraries/BatchedBridge/NativeModules', () => {
    return {
        RNQualtricsDigital: {
            evaluateTargetingLogic: jest.fn(() => {
            }),
            evaluateIntercept: jest.fn(() => {
            }),
            evaluateProject: jest.fn(() => {
            })
        },
    };
});

describe('evaluateTargetingLogic with callback', function () {
    beforeEach(() => {
        RNQualtricsDigital.evaluateTargetingLogic.mockClear();
        RNQualtricsDigital.evaluateTargetingLogic = jest.fn(() => {
            nativeEventEmitter.emit('evaluateEvent', mockTargetingResult);
        });
        spyConsoleLog.mockReset();
    });

    it('should not call evaluateTargetingLogic with invalid callback parameter type', function () {
        Qualtrics.evaluateTargetingLogic(undefined);
        expect(RNQualtricsDigital.evaluateTargetingLogic).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.evaluateTargetingLogic(123);
        expect(RNQualtricsDigital.evaluateTargetingLogic).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.evaluateTargetingLogic(null);
        expect(RNQualtricsDigital.evaluateTargetingLogic).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should call evaluateTargetingLogic and set callback result to mockTargetingResult given valid callback result of passed equals true and callback function', done => {
        mockTargetingResult = {
            passed: true,
            surveyUrl: successMessage
        }

        var mockCallback = function(result) {
            expect(result.passed).toBe(true);
            expect(result.surveyUrl).toBe(successMessage);
            done();
        }

        Qualtrics.evaluateTargetingLogic(mockCallback);
        expect(RNQualtricsDigital.evaluateTargetingLogic).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateTargetingLogic.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call evaluateTargetingLogic and set callback result to mockTargetingResult given valid callback result of passed equals false and callback function', done => {
        mockTargetingResult = {
            passed: false,
            surveyUrl: null
        }

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.surveyUrl).toBe(null);
            done();
        }

        Qualtrics.evaluateTargetingLogic(mockCallback);
        expect(RNQualtricsDigital.evaluateTargetingLogic).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateTargetingLogic.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call evaluateTargetingLogic and set callback result to failed mockTargetingResult given callback function and null callback result', done => {
        mockTargetingResult = null;

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.surveyUrl).toBe('Invalid TargetingResult Received');
            done();
        }

        Qualtrics.evaluateTargetingLogic(mockCallback);
        expect(RNQualtricsDigital.evaluateTargetingLogic).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateTargetingLogic.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call evaluateTargetingLogic only once and set callback result to true in case of multiple evaluateTargetingLogic calls', done => {
        mockTargetingResult = {
            passed: false,
            surveyUrl: null
        }
        RNQualtricsDigital.evaluateTargetingLogic.mockClear();
        RNQualtricsDigital.evaluateTargetingLogic = jest.fn((brandid, projectid, interceptid) => {
            setTimeout(()=> {
                nativeEventEmitter.emit('evaluateEvent', mockTargetingResult);
            }, 2000);
        });

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.surveyUrl).toBe(null);
            done();
        }

        Qualtrics.evaluateTargetingLogic(mockCallback);
        Qualtrics.evaluateTargetingLogic(mockCallback);

        expect(RNQualtricsDigital.evaluateTargetingLogic).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateTargetingLogic.mock.calls.length).toBe(1);
    }, 6000);

});

describe('evaluateIntercept with callback', function() {
    beforeEach(() => {
        RNQualtricsDigital.evaluateIntercept.mockClear();
        RNQualtricsDigital.evaluateIntercept = jest.fn((interceptId) => {
            nativeEventEmitter.emit('evaluateInterceptEvent', mockTargetingResult);
        });
        spyConsoleLog.mockReset();
    });

    it('should not call evaluateIntercept with invalid callback parameter type', function () {
        Qualtrics.evaluateIntercept(undefined);
        expect(RNQualtricsDigital.evaluateIntercept).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.evaluateIntercept(123);
        expect(RNQualtricsDigital.evaluateIntercept).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.evaluateIntercept(null);
        expect(RNQualtricsDigital.evaluateIntercept).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should call evaluateIntercept and set callback result to mockTargetingResult given valid callback result of passed equals true and callback function', done => {
        mockTargetingResult = {
            passed: true,
            surveyUrl: successMessage
        }

        var mockCallback = function(result) {
            expect(result.passed).toBe(true);
            expect(result.surveyUrl).toBe(successMessage);
            done();
        }

        Qualtrics.evaluateIntercept("MOCK_INTERCEPT", mockCallback);
        expect(RNQualtricsDigital.evaluateIntercept).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateIntercept.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call evaluateIntercept and set callback result to mockTargetingResult given valid callback result of passed equals false and callback function', done => {
        mockTargetingResult = {
            passed: false,
            surveyUrl: null
        }

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.surveyUrl).toBe(null);
            done();
        }

        Qualtrics.evaluateIntercept("MOCK_INTERCEPT", mockCallback);
        expect(RNQualtricsDigital.evaluateIntercept).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateIntercept.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });


    it('should call evaluateIntercept and set callback result to failed mockTargetingResult given callback function and null callback result', done => {
        mockTargetingResult = null;

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.surveyUrl).toBe('Invalid TargetingResult Received');
            done();
        }

        Qualtrics.evaluateIntercept("MOCK_INTERCEPT", mockCallback);
        expect(RNQualtricsDigital.evaluateIntercept).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateIntercept.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call evaluateIntercept only once and set callback result to true in case of multiple evaluateTargetingLogic calls', done => {
        mockTargetingResult = {
            passed: false,
            surveyUrl: null
        }
        RNQualtricsDigital.evaluateIntercept.mockClear();
        RNQualtricsDigital.evaluateIntercept = jest.fn((brandid, projectid, interceptid) => {
            setTimeout(()=> {
                nativeEventEmitter.emit('evaluateInterceptEvent', mockTargetingResult);
            }, 2000);
        });

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.surveyUrl).toBe(null);
            done();
        }

        Qualtrics.evaluateIntercept("MOCK_INTERCEPT", mockCallback);
        Qualtrics.evaluateIntercept("MOCK_INTERCEPT", mockCallback);

        expect(RNQualtricsDigital.evaluateIntercept).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateIntercept.mock.calls.length).toBe(1);
    }, 6000);
});

describe("evaluateProject with callback", function() {
    beforeEach(() => {
        RNQualtricsDigital.evaluateProject.mockClear();
        RNQualtricsDigital.evaluateProject = jest.fn(() => {
            nativeEventEmitter.emit('evaluateProjectEvent', mockTargetingResult);
        });
        spyConsoleLog.mockReset();
    });

    it('should not call evaluateProject with invalid callback parameter type', function () {
        Qualtrics.evaluateProject(undefined);
        expect(RNQualtricsDigital.evaluateProject).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.evaluateProject(123);
        expect(RNQualtricsDigital.evaluateProject).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.evaluateProject(null);
        expect(RNQualtricsDigital.evaluateProject).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should call evaluateProject and set callback result to mockTargetingResult given valid callback result of passed equals true and callback function', done => {
        mockTargetingResult = {
            "MOCK_INTERCEPT_1": {
                "passed": true,
                "surveyUrl": successMessage
            },
            "MOCK_INTERCEPT_2": {
                "passed": false,
                "surveyUrl": null
            }
        }

        var mockCallback = function(result) {
            expect(result["MOCK_INTERCEPT_1"].passed).toBe(true);
            expect(result["MOCK_INTERCEPT_1"].surveyUrl).toBe(successMessage);

            expect(result["MOCK_INTERCEPT_2"].passed).toBe(false);
            expect(result["MOCK_INTERCEPT_2"].surveyUrl).toBe(null);
            done();
        }

        Qualtrics.evaluateProject(mockCallback);
        expect(RNQualtricsDigital.evaluateProject).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateProject.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });


    it('should call evaluateProject and set callback result to failed mockTargetingResult given callback function and null callback result', done => {
        mockTargetingResult = null;

        var mockCallback = function(result) {
            expect(result["ERROR"].passed).toBe(false);
            expect(result["ERROR"].surveyUrl).toBe('Invalid TargetingResult Received');
            done();
        }

        Qualtrics.evaluateProject(mockCallback);
        expect(RNQualtricsDigital.evaluateProject).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateProject.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call evaluateProject only once and set callback result to true in case of multiple evaluateProject calls', done => {
        mockTargetingResult = {
            "MOCK_INTERCEPT_1": {
                "passed": true,
                "surveyUrl": successMessage
            },
            "MOCK_INTERCEPT_2": {
                "passed": false,
                "surveyUrl": null
            }
        }
        RNQualtricsDigital.evaluateProject.mockClear();
        RNQualtricsDigital.evaluateProject = jest.fn((brandid, projectid, interceptid) => {
            setTimeout(()=> {
                nativeEventEmitter.emit('evaluateProjectEvent', mockTargetingResult);
            }, 2000);
        });

        var mockCallback = function(result) {
            expect(result["MOCK_INTERCEPT_1"].passed).toBe(true);
            expect(result["MOCK_INTERCEPT_1"].surveyUrl).toBe(successMessage);

            expect(result["MOCK_INTERCEPT_2"].passed).toBe(false);
            expect(result["MOCK_INTERCEPT_2"].surveyUrl).toBe(null);
            done();
        }
        Qualtrics.evaluateProject(mockCallback);
        Qualtrics.evaluateProject(mockCallback);

        expect(RNQualtricsDigital.evaluateIntercept).toHaveBeenCalled();
        expect(RNQualtricsDigital.evaluateIntercept.mock.calls.length).toBe(1);
    }, 6000);
});


