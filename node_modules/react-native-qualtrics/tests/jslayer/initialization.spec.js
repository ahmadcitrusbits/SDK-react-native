/**
 * react-native-qualtrics // npm module
 * unit tests for initialization()
 */

import Qualtrics, {
    RNQualtricsDigital,
    initialize
} from '../../index.js';

import { NativeModules, NativeEventEmitter } from 'react-native';

var mockBrandId = "mybrand";
var mockZoneId = "ZN_123";
var mockInterceptId = "SI_456";
var mockExtRefId = "elmo";
var mockInitializationResult = {};
var successMessage = 'initialization successful';
var typeError = 'TypeError';

const spyConsoleLog = jest.spyOn(global.console, 'log');

jest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');
const nativeEventEmitter = new NativeEventEmitter();

jest.mock('react-native/Libraries/BatchedBridge/NativeModules', () => {
    return {
        RNQualtricsDigital: {
            initialize: jest.fn(),
            initializeWithCompletion: jest.fn((brandid, projectid, interceptid) => {
            }),
            setString: jest.fn(),
            initializeProject: jest.fn()
        },
    };
});

describe('initialization without callback', function () {
    beforeEach(() => {
        RNQualtricsDigital.initialize.mockClear();
        spyConsoleLog.mockReset();
    });

    it('should not call initialize and log error with no parameter', function () {
        Qualtrics.initialize();
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should not call initialize and log error with 1 parameter', function () {
        Qualtrics.initialize(mockBrandId);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should not call initialize and log error with 2 parameters', function () {
        Qualtrics.initialize(mockBrandId, mockZoneId);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should not call initialize and log error with invalid parameter types', function () {
        Qualtrics.initialize(mockBrandId, mockZoneId, 123);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(mockBrandId, null, mockInterceptId);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(undefined, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(undefined, null, mockInterceptId);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(undefined, mockZoneId, true);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(mockBrandId, 1.0, true);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(null, 1.0, true);
        expect(RNQualtricsDigital.initialize).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should call initialize with 3 parameters given valid brandid, zoneid, and interceptid', function () {
        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initialize).toBeCalledWith(mockBrandId, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initialize.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });
});

describe('initialization with callback', function () {
    beforeEach(() => {
        RNQualtricsDigital.initializeWithCompletion.mockClear();
        RNQualtricsDigital.initializeWithCompletion = jest.fn((brandid, projectid, interceptid) => {
            nativeEventEmitter.emit('initializeEvent', mockInitializationResult);
        });
        spyConsoleLog.mockReset();
    });

    it('should not call initialize and log error with invalid callback parameter type', function () {
        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, true);
        expect(RNQualtricsDigital.initializeWithCompletion).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, 123);
        expect(RNQualtricsDigital.initializeWithCompletion).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, null);
        expect(RNQualtricsDigital.initializeWithCompletion).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should call initializeWithCompletion and set callback result to mockInitializationResult given valid callback result with passed equals true and valid callback function', done => {
        mockInitializationResult = {
            passed: true,
            message: successMessage
        };

        var mockCallback = function(result) {
        expect(result.passed).toBe(true);
            expect(result.message).toBe(successMessage);
            done();
        }

        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, mockCallback);
        expect(RNQualtricsDigital.initializeWithCompletion).toBeCalledWith(mockBrandId, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initializeWithCompletion.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call initializeWithCompletion and set callback result to mockInitializationResult given valid callback result of passed equals false and valid callback function', done => {
        mockInitializationResult = {
            passed: false,
            message: null
        };

        var mockCallback = function(result) {
            expect(result.passed).toBe(false);
            expect(result.message).toBe(null);
            done();
        }

        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, mockCallback);
        expect(RNQualtricsDigital.initializeWithCompletion).toBeCalledWith(mockBrandId, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initializeWithCompletion.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call initializeWithCompletion and set callback result to failed mockInitializationResult given valid parameters and null callback result', done => {
        mockInitializationResult = null;

        var mockCallback = function(result) {
        expect(result.passed).toBe(false);
        expect(result.message).toBe('Invalid InitializationResult Received');
        done();
        }

        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, mockCallback);
        expect(RNQualtricsDigital.initializeWithCompletion).toBeCalledWith(mockBrandId, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initializeWithCompletion.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call initializeCompletion only once and set callback result to true in case of multiple initialization calls', done => {
        mockInitializationResult = {
            passed: true,
            message: successMessage
        };
        RNQualtricsDigital.initializeWithCompletion.mockClear();
        RNQualtricsDigital.initializeWithCompletion = jest.fn((brandid, projectid, interceptid) => {
            setTimeout(()=> {
                nativeEventEmitter.emit('initializeEvent', mockInitializationResult);
            }, 2000);
        });

        var mockCallback = function(result) {
        expect(result.passed).toBe(true);
            expect(result.message).toBe(successMessage);
            done();
        }

        Qualtrics.initialize(mockBrandId, mockZoneId, mockInterceptId, mockCallback);
        Qualtrics.initialize("mockBrandId", "mockZoneId", "mockInterceptId", mockCallback);

        expect(RNQualtricsDigital.initializeWithCompletion).toBeCalledWith(mockBrandId, mockZoneId, mockInterceptId);
        expect(RNQualtricsDigital.initializeWithCompletion.mock.calls.length).toBe(1);
    }, 6000);

 });


 describe('initializeProject with callback', function () {
    beforeEach(() => {
        RNQualtricsDigital.initializeProject.mockClear();
        RNQualtricsDigital.initializeProject = jest.fn((brandid, projectid, mockExtRefId) => {
            nativeEventEmitter.emit('initializeProjectEvent', mockInitializationResult);
        });
        spyConsoleLog.mockReset();
    });

    it('should not call initializeProject and log error with invalid callback parameter type', function () {
        Qualtrics.initializeProject(mockBrandId, mockZoneId, mockExtRefId, true);
        expect(RNQualtricsDigital.initializeProject).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initializeProject(mockBrandId, mockZoneId, mockExtRefId, 123);
        expect(RNQualtricsDigital.initializeProject).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));

        Qualtrics.initializeProject(mockBrandId, mockZoneId, mockExtRefId, null);
        expect(RNQualtricsDigital.initializeProject).not.toHaveBeenCalled();
        expect(spyConsoleLog).toHaveBeenCalledWith(expect.stringContaining(typeError));
    });

    it('should call initializeProject and set callback result to mockInitializationResult given valid callback result with passed equals true and valid callback function', done => {
        mockInitializationResult = {
            "MOCK_INTERCEPT_1": 
            {
                "passed": true,
                "message": successMessage
            },
            "MOCK_INTERCEPT_2": 
            {
                "passed": true,
                "message": successMessage
            }
        };

        var mockCallback = function(result) {
            expect(result["MOCK_INTERCEPT_1"].passed).toBe(true);
            expect(result["MOCK_INTERCEPT_1"].message).toBe(successMessage);


            expect(result["MOCK_INTERCEPT_2"].passed).toBe(true);
            expect(result["MOCK_INTERCEPT_2"].message).toBe(successMessage);
            done();
        }

        Qualtrics.initializeProject(mockBrandId, mockZoneId, mockExtRefId, mockCallback);
        expect(RNQualtricsDigital.initializeProject).toBeCalledWith(mockBrandId, mockZoneId, mockExtRefId);
        expect(RNQualtricsDigital.initializeProject.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call initializeProject and set callback result to failed mockInitializationResult given valid parameters and null callback result', done => {
        mockInitializationResult = null;

        var mockCallback = function(result) {
            expect(result["ERROR"].passed).toBe(false);
            expect(result["ERROR"].message).toBe('Invalid InitializationResult Received');
            done();
        }

        Qualtrics.initializeProject(mockBrandId, mockZoneId, mockExtRefId, mockCallback);
        expect(RNQualtricsDigital.initializeProject).toBeCalledWith(mockBrandId, mockZoneId, mockExtRefId);
        expect(RNQualtricsDigital.initializeProject.mock.calls.length).toBe(1);
        expect(spyConsoleLog).not.toHaveBeenCalled();
    });

    it('should call initializeProject only once and set callback result to true in case of multiple initializeProject calls', done => {
        mockInitializationResult = {
            "MOCK_INTERCEPT_1": 
            {
                "passed": true,
                "message": successMessage
            },
            "MOCK_INTERCEPT_2": 
            {
                "passed": true,
                "message": successMessage
            }
        };
        RNQualtricsDigital.initializeProject.mockClear();
        RNQualtricsDigital.initializeProject = jest.fn((brandid, projectid, mockExtRefId) => {
            setTimeout(()=> {
                nativeEventEmitter.emit('initializeProjectEvent', mockInitializationResult);
            }, 2000);
        });

        var mockCallback = function(result) {
            expect(result["MOCK_INTERCEPT_1"].passed).toBe(true);
            expect(result["MOCK_INTERCEPT_1"].message).toBe(successMessage);


            expect(result["MOCK_INTERCEPT_2"].passed).toBe(true);
            expect(result["MOCK_INTERCEPT_2"].message).toBe(successMessage);
            done();
        }

        Qualtrics.initializeProject(mockBrandId, mockZoneId, mockExtRefId, mockCallback);
        Qualtrics.initializeProject("mockBrandId", "mockZoneId", "mockExtRefId", mockCallback);

        expect(RNQualtricsDigital.initializeProject).toBeCalledWith(mockBrandId, mockZoneId, mockExtRefId);
        expect(RNQualtricsDigital.initializeProject.mock.calls.length).toBe(1);
    }, 6000);
 });